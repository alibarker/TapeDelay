/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"



//==============================================================================
TapeDelayAudioProcessor::TapeDelayAudioProcessor()
{
    // Add parameters in order of enum in .h file
    addParameter(pInputGain = new AudioParameterFloat("in", "Input Gain", -100, +6, 0));
    addParameter(pOutputGain = new AudioParameterFloat("out", "Output Gain", -100, +6, 0));
    addParameter(pFeedback = new AudioParameterFloat("2", "Feedback", -100, 20, -18));
    addParameter(pSpeed = new AudioParameterFloat("speed", "Speed", 0.25, 4, 1));
    addParameter(pDistortion = new AudioParameterFloat("dist", "Distortion", 0, 1, 0));
    addParameter(pWowAmount = new AudioParameterFloat("wow", "Wow Gain", 0, 0.2, 0));
    addParameter(pFlutterAmount = new AudioParameterFloat("flutter", "Flutter Gain", 0, 0.2, 0));
    addParameter(pLowCutoff = new AudioParameterFloat("hc", "Low Cutoff", 50, 2000, 50));
    addParameter(pHighCutoff = new AudioParameterFloat("lc", "High Cutoff", 500, 15000, 15000));

    for (int i = 0; i < numReadHeads; i++)
    {
        pReadPositions.add(new AudioParameterFloat("3", &"Read Head Position " [i], 10, 4000, 100 + i*200));
        addParameter(pReadPositions[i]);
    }
    
    addParameter(pReadGain1 = new AudioParameterFloat("3", "Read Head Gain 1", -100, 6, -12));
    addParameter(pReadGain2 = new AudioParameterFloat("3", "Read Head Gain 2", -100, 6, -12));
    addParameter(pReadGain3 = new AudioParameterFloat("3", "Read Head Gain 3", -100, 6, -12));

    // Setup various objects
    tape = new VariableDelayLine();
    tapeSaturator = new Compressor;
    wowLFO = new LFO;
    flutterLFO = new LFO;
    dist = new MultiDistortion;
    
}

TapeDelayAudioProcessor::~TapeDelayAudioProcessor()
{
}

//==============================================================================
const String TapeDelayAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool TapeDelayAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool TapeDelayAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool TapeDelayAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double TapeDelayAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int TapeDelayAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int TapeDelayAudioProcessor::getCurrentProgram()
{
    return 0;
}

void TapeDelayAudioProcessor::setCurrentProgram (int index)
{
}

const String TapeDelayAudioProcessor::getProgramName (int index)
{
    return String();
}

void TapeDelayAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void TapeDelayAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    
    // Setup LFOs
    wowLFO->setRate(0.3, sampleRate);
    flutterLFO->setRate(10, sampleRate);

    // setup feedback 'saturator'
    tapeSaturator->setParameters(100, -10, 5, 30, 1, 0);
    tapeSaturator->prepareToPlay(sampleRate, samplesPerBlock, 1);
    
    // set up filters
    previousLowCutoff = *pLowCutoff;
    previousHighCutoff = * pHighCutoff;
    
    tapeLowPass = new IIRFilter();
    tapeLowPass->setCoefficients(IIRCoefficients::makeLowPass(sampleRate, previousHighCutoff));
    
    tapeMidBoost = new IIRFilter();
    tapeMidBoost->setCoefficients(IIRCoefficients::makePeakFilter(sampleRate, 500, 0.5, Decibels::decibelsToGain(+6)));
    
    tapeHighPass = new IIRFilter();
    tapeHighPass->setCoefficients(IIRCoefficients::makeHighPass(sampleRate, previousLowCutoff));
    int readPos[numReadHeads];
    
    // set previous read position states
    previousReadPos = new float[numReadHeads];
    for (int i = 0; i < numReadHeads; i++) {
        previousReadPos[i] = readPos[i] = floor(*pReadPositions[i] * sampleRate/1000);
    }
    
    // initialise delay line
    tape->prepareToPlay(3, readPos);
    
    // set distortion threshold
    dist->setTreshold(0.2);

}

void TapeDelayAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void TapeDelayAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    
    float sampleRate = getSampleRate();
    int numSamples = buffer.getNumSamples();
    int numChannels = buffer.getNumChannels();
    

    // sample process loop
    for (int n = 0; n < numSamples; n++)
    {
        float input = 0;

        // Mono sum
        for (int channel = 0; channel < numChannels; ++channel)
        {
            input += buffer.getSample(channel, n);
        }
        
        input /= numChannels;
        
        float tapeOutput = 0;
        
        
        // add instantaneous wow & flutter amounts to speed
        float speed = *pSpeed * (1 + wowLFO->getNextSample()* *pWowAmount)  * (1 + flutterLFO->getNextSample() * *pFlutterAmount);
        
        // Limit speed
        if (speed < 0.1)
            speed = 0.1;
        
        tape->setSpeed(speed);
        
        // set read positions for each read head
        for (int i = 0; i < numReadHeads; i++) {
            if (*pReadPositions[i] != previousReadPos[i]) {
                tape->setReadPosition(i, *pReadPositions[i] * sampleRate /1000);
                previousReadPos[i] = *pReadPositions[i];
            }
        }
        
        // read sample from each read head
        tapeOutput += tape->readSample(0) * Decibels::decibelsToGain((float)*pReadGain1);
        tapeOutput += tape->readSample(1) * Decibels::decibelsToGain((float)*pReadGain2);
        tapeOutput += tape->readSample(2) * Decibels::decibelsToGain((float)*pReadGain3);

        
        // generate input from read samples (with feedback) and input
        float tapeInput = tapeOutput * Decibels::decibelsToGain((float)*pFeedback) + input;
        
        // apply tape 'saturator'
        tapeInput = tapeSaturator->processSample(tapeInput);
        
        // set distortion amount and apply
        dist->setDist(*pDistortion * 9 + 1);
        dist->setGain(1 + Decibels::decibelsToGain(*pDistortion * 12));
        tapeInput = dist->processSample(tapeInput, distTypeTube);
        
        // if the high and low pass filters have changed calculate new coefficients
        if (*pLowCutoff!= previousLowCutoff)
        {
            tapeHighPass->setCoefficients(IIRCoefficients::makeHighPass(sampleRate, *pLowCutoff));
            previousLowCutoff = *pLowCutoff;
        }
        
        if (*pHighCutoff!= previousHighCutoff)
        {
            tapeLowPass->setCoefficients(IIRCoefficients::makeLowPass(sampleRate, *pHighCutoff));
            previousHighCutoff = *pHighCutoff;
        }
        
        // apply filters to input
        tapeInput = tapeLowPass->processSingleSampleRaw(tapeInput);
        tapeInput = tapeHighPass->processSingleSampleRaw(tapeInput);
        tapeInput = tapeMidBoost->processSingleSampleRaw(tapeInput);

        // hard clip input just in case
        if (fabs(tapeInput) >= 1) {
            tapeInput /= fabs(tapeInput);
        }
        
        // write input to delay line
        tape->writeSample(tapeInput);
        
        // apply input to each channel
        for (int i = 0; i < numChannels; i++)
        {
            buffer.setSample(i, n,  input * Decibels::decibelsToGain((float)*pInputGain) + tapeOutput * Decibels::decibelsToGain((float)*pOutputGain));
        }
        
    }
}

//==============================================================================
bool TapeDelayAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* TapeDelayAudioProcessor::createEditor()
{
    return new TapeDelayAudioProcessorEditor (this);
}

//==============================================================================
void TapeDelayAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void TapeDelayAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new TapeDelayAudioProcessor();
}
