/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"



//==============================================================================
TapeDelayAudioProcessor::TapeDelayAudioProcessor()
{
    // Add parameters in order of enum
    addParameter(pInputGain = new AudioParameterFloat("in", "Input Gain", 0, 1, 1));
    addParameter(pOutputGain = new AudioParameterFloat("out", "Output Gain", 0, 1, 1));
    addParameter(pFeedback = new AudioParameterFloat("2", "Feedback", 0, 1, 0.25));
    addParameter(pSpeed = new AudioParameterFloat("speed", "Speed", 0.25, 4, 1));
    
    addParameter(pReadPosition1 = new AudioParameterFloat("3", "Read Head Position 1", 0, 4000, 100));
    addParameter(pReadPosition2 = new AudioParameterFloat("3", "Read Head Position 2", 0, 4000, 300));
    addParameter(pReadPosition3 = new AudioParameterFloat("3", "Read Head Position 3", 0, 4000, 500));
    addParameter(pReadGain1 = new AudioParameterFloat("3", "Read Head Gain 1", 0, 1, 0.5));
    addParameter(pReadGain2 = new AudioParameterFloat("3", "Read Head Gain 2", 0, 1, 0.5));
    addParameter(pReadGain3 = new AudioParameterFloat("3", "Read Head Gain 3", 0, 1, 0.5));

    // Setup Delayline
    tape = new VariableDelayLine();
    
}

TapeDelayAudioProcessor::~TapeDelayAudioProcessor()
{
}

//==============================================================================
const String TapeDelayAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool TapeDelayAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool TapeDelayAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool TapeDelayAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double TapeDelayAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int TapeDelayAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int TapeDelayAudioProcessor::getCurrentProgram()
{
    return 0;
}

void TapeDelayAudioProcessor::setCurrentProgram (int index)
{
}

const String TapeDelayAudioProcessor::getProgramName (int index)
{
    return String();
}

void TapeDelayAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void TapeDelayAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    
    int readPos[numReadHeads];
    
    readPos[0] = floor(*pReadPosition1 * sampleRate / 1000);
    readPos[1] = floor(*pReadPosition2 * sampleRate / 1000);
    readPos[2] = floor(*pReadPosition3 * sampleRate / 1000);
    //THIS NEEDS TO CHANGE TO INTS

    tape->prepareToPlay(3, readPos);
    
    int numChannels = getTotalNumInputChannels();
    
    for (int i = 0; i < numChannels; i++)
    {
        highpass.add(new IIRFilter);
        highpass[i]->setCoefficients(IIRCoefficients::makeHighPass(getSampleRate(), 100));
    }
    
}

void TapeDelayAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void TapeDelayAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // update parameters
    float speed = *pSpeed;
    tape->setSpeed(speed);
    DBG("Speed:" << speed);
    
    float sampleRate = getSampleRate();
    
    DBG("Feedback:\t" << *pFeedback);
    DBG("Input Gain:\t" << *pInputGain);
    DBG("Input Gain:\t" << *pOutputGain);

    int numSamples = buffer.getNumSamples();
    int numChannels = buffer.getNumChannels();
    
    AudioSampleBuffer tapeOutput;
    AudioSampleBuffer tapeInput;
    
    tapeOutput.setSize(1, numSamples);
    tapeInput.setSize(1, numSamples);
    
    tapeInput.clear();
    tapeOutput.clear();
    
    

    
    // Read from tape
    
    // Prepare input to be written to tape
    
    // Apply feedback processing
    for (int n = 0; n < numSamples; n++)
    {
        float input = 0;

        // Mono sum
        for (int channel = 0; channel < numChannels; ++channel)
        {
            input += buffer.getSample(channel, n);
        }
        
        float tapeOutput = 0;
        
        
        tape->setReadPosition(0, floor(*pReadPosition1 * sampleRate / 1000));
        tape->setReadPosition(1, floor(*pReadPosition2 * sampleRate / 1000));
        tape->setReadPosition(2, floor(*pReadPosition3 * sampleRate / 1000));

        tapeOutput += tape->readSample(0) * *pReadGain1;
        tapeOutput += tape->readSample(1) * *pReadGain2;
        tapeOutput += tape->readSample(2) * *pReadGain3;

        float tapeInput = tapeOutput * *pFeedback + input;
        
//        dist.setGain(1);
    
//        tapeInput = highpass[0]->processSingleSampleRaw(dist.processSample(tapeInput, distTypeTube));
        
        tape->writeSample(tapeInput);
        
        
        buffer.setSample(0, n, input * *pInputGain + tapeOutput * *pOutputGain);
        
        
    }
    
    
    // Write to tape

}

//==============================================================================
bool TapeDelayAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* TapeDelayAudioProcessor::createEditor()
{
    return new TapeDelayAudioProcessorEditor (this);
}

//==============================================================================
void TapeDelayAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void TapeDelayAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new TapeDelayAudioProcessor();
}
