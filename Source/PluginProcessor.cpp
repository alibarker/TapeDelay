/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"



//==============================================================================
TapeDelayAudioProcessor::TapeDelayAudioProcessor()
{
    // Add parameters in order of enum
    addParameter(pInputGain = new AudioParameterFloat("in", "Input Gain", -100, +6, 0));
    addParameter(pOutputGain = new AudioParameterFloat("out", "Output Gain", -100, +6, 0));
    addParameter(pFeedback = new AudioParameterFloat("2", "Feedback", -100, 20, -18));
    addParameter(pSpeed = new AudioParameterFloat("speed", "Speed", 0.25, 4, 1));
    addParameter(pDistortion = new AudioParameterFloat("dist", "Distortion", 0, 1, 0));
    addParameter(pWowAmount = new AudioParameterFloat("wow", "Wow Gain", 0, 0.2, 0));
    addParameter(pFlutterAmount = new AudioParameterFloat("flutter", "Flutter Gain", 0, 0.2, 0));
    addParameter(pLowCutoff = new AudioParameterFloat("hc", "Low Cutoff", 50, 2000, 50));
    addParameter(pHighCutoff = new AudioParameterFloat("lc", "High Cutoff", 500, 15000, 15000));


    for (int i = 0; i < numReadHeads; i++)
    {
        pReadPositions.add(new AudioParameterFloat("3", &"Read Head Position " [i], 10, 4000, 100 + i*200));
        addParameter(pReadPositions[i]);
    }
    
    addParameter(pReadGain1 = new AudioParameterFloat("3", "Read Head Gain 1", -100, 6, -12));
    addParameter(pReadGain2 = new AudioParameterFloat("3", "Read Head Gain 2", -100, 6, -12));
    addParameter(pReadGain3 = new AudioParameterFloat("3", "Read Head Gain 3", -100, 6, -12));

    // Setup Delayline
    tape = new VariableDelayLine();
    
    tapeSaturator = new Compressor;
    
    wowLFO = new LFO;
    flutterLFO = new LFO;
    
}

TapeDelayAudioProcessor::~TapeDelayAudioProcessor()
{
}

//==============================================================================
const String TapeDelayAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool TapeDelayAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool TapeDelayAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool TapeDelayAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double TapeDelayAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int TapeDelayAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int TapeDelayAudioProcessor::getCurrentProgram()
{
    return 0;
}

void TapeDelayAudioProcessor::setCurrentProgram (int index)
{
}

const String TapeDelayAudioProcessor::getProgramName (int index)
{
    return String();
}

void TapeDelayAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void TapeDelayAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    
    wowLFO->setRate(0.3, sampleRate);
    flutterLFO->setRate(10, sampleRate);

    tapeSaturator->setParameters(100, -10, 5, 30, 1, 0);
    tapeSaturator->prepareToPlay(sampleRate, samplesPerBlock, 1);
    

    previousLowCutoff = *pLowCutoff;
    previousHighCutoff = * pHighCutoff;
    
    tapeLowPass = new IIRFilter();
    tapeLowPass->setCoefficients(IIRCoefficients::makeLowPass(sampleRate, previousHighCutoff));
    
    tapeMidBoost = new IIRFilter();
    tapeMidBoost->setCoefficients(IIRCoefficients::makePeakFilter(sampleRate, 500, 0.5, Decibels::decibelsToGain(+6)));
    
    tapeHighPass = new IIRFilter();
    tapeHighPass->setCoefficients(IIRCoefficients::makeHighPass(sampleRate, previousLowCutoff));
    int readPos[numReadHeads];
    
    
    
    resamplerFilter = new IIRFilter();
    resamplerFilter->setCoefficients(IIRCoefficients::makeLowPass(sampleRate, sampleRate/2));
    
    previousReadPos = new float[numReadHeads];
    
    for (int i = 0; i < numReadHeads; i++) {
        previousReadPos[i] = readPos[i] = floor(*pReadPositions[i] * sampleRate/1000);
    }
    
    tape->prepareToPlay(3, readPos);
    
    dist.setGain(1);
    dist.setTreshold(0.2);

    int numChannels = getTotalNumInputChannels();
    
    for (int i = 0; i < numChannels; i++)
    {
        highpass.add(new IIRFilter);
        highpass[i]->setCoefficients(IIRCoefficients::makeHighPass(getSampleRate(), 100));
    }
    
}

void TapeDelayAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void TapeDelayAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // update parameters
    
    float sampleRate = getSampleRate();
    
//    DBG("Feedback:\t" << *pFeedback);
//    DBG("Input Gain:\t" << *pInputGain);
//    DBG("Output Gain:\t" << *pOutputGain);
//    DBG("Speed:\t" << *pSpeed);
//    DBG("Dist Gain:\t" << *pDistGain);
//    DBG("Distortion:\t" << *pDistortion);
//    DBG("Q:\t" << *pQ);
//
    
    
    int numSamples = buffer.getNumSamples();
    int numChannels = buffer.getNumChannels();
    
    
    // Read from tape
    
    // Prepare input to be written to tape
    
    // Apply feedback processing
    for (int n = 0; n < numSamples; n++)
    {
        float input = 0;

        // Mono sum
        for (int channel = 0; channel < numChannels; ++channel)
        {
            input += buffer.getSample(channel, n);
        }
        
        float tapeOutput = 0;
        
        float wow = wowLFO->getNextSample()* *pWowAmount;
        float flutter = flutterLFO->getNextSample() * *pFlutterAmount;
        
        float speed = *pSpeed * (1 + wow)  * (1 + flutter);
        
//        DBG("Wow:\t" << wow << "Flutter:\t" << flutter);
        
        if (speed < 0.1)
            speed = 0.1;
        
        tape->setSpeed(speed);
        
  
        for (int i = 0; i < numReadHeads; i++) {
            if (*pReadPositions[i] != previousReadPos[i]) {
                tape->setReadPosition(i, *pReadPositions[i] * sampleRate /1000);
                previousReadPos[i] = *pReadPositions[i];
            }
        }

        tapeOutput += tape->readSample(0) * Decibels::decibelsToGain((float)*pReadGain1);
        tapeOutput += tape->readSample(1) * Decibels::decibelsToGain((float)*pReadGain2);
        tapeOutput += tape->readSample(2) * Decibels::decibelsToGain((float)*pReadGain3);

        
        tapeOutput = tapeSaturator->processSample(tapeOutput);
        
        
        float tapeInput = tapeOutput * Decibels::decibelsToGain((float)*pFeedback) + input;
        
        
        
//        float tapeInput = input;
        
        
        dist.setDist(*pDistortion * 9 + 1);
        dist.setGain(1 + Decibels::decibelsToGain(*pDistortion * 12));
        tapeInput = dist.processSample(tapeInput, distTypeTube);
        
        
        if (*pLowCutoff!= previousLowCutoff)
        {
            tapeHighPass->setCoefficients(IIRCoefficients::makeHighPass(sampleRate, *pLowCutoff));
            previousLowCutoff = *pLowCutoff;
        }
        
        if (*pHighCutoff!= previousHighCutoff)
        {
            tapeLowPass->setCoefficients(IIRCoefficients::makeLowPass(sampleRate, *pHighCutoff));
            previousHighCutoff = *pHighCutoff;
        }
        
        tapeInput = tapeLowPass->processSingleSampleRaw(tapeInput);
        tapeInput = tapeHighPass->processSingleSampleRaw(tapeInput);

        tapeInput = tapeMidBoost->processSingleSampleRaw(tapeInput);
        tapeInput = tapeSaturator->processSample(tapeInput);

        tape->writeSample(tapeInput);
        
        
        if (fabs(tapeInput) >= 1) {
            tapeInput /= fabs(tapeInput);
        }
        
        buffer.setSample(0, n,  input * Decibels::decibelsToGain((float)*pInputGain) + tapeOutput * Decibels::decibelsToGain((float)*pOutputGain));
        
    }
    
    
    // Write to tape

}

//==============================================================================
bool TapeDelayAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* TapeDelayAudioProcessor::createEditor()
{
    return new TapeDelayAudioProcessorEditor (this);
}

//==============================================================================
void TapeDelayAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void TapeDelayAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new TapeDelayAudioProcessor();
}
